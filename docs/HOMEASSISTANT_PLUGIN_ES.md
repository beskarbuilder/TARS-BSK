# Sistema Inteligente de Control Dom√≥tico TARS-BSK

![TARS-BSK Home](https://img.shields.io/badge/TARS--BSK-Home%20Assistant-blue) ![Contextual Control](https://img.shields.io/badge/Control-Contextual-orange) ![Voice Ready](https://img.shields.io/badge/Voice-Ready-darkgreen) ![AI Powered](https://img.shields.io/badge/AI-Powered-purple) ![Context Aware](https://img.shields.io/badge/Context-Aware-red)

## üìã Tabla de Contenidos

- [Introducci√≥n](#-introducci%C3%B3n)
- [Configuraci√≥n inicial OBLIGATORIA](#%EF%B8%8F-configuraci%C3%B3n-inicial-obligatoria)
- [Arquitectura actual del plugin](#%EF%B8%8F-arquitectura-actual-del-plugin)
- [Nueva configuraci√≥n maestra de dispositivos](#-nueva-configuraci%C3%B3n-maestra-de-dispositivos)
- [C√≥mo a√±adir un nuevo dispositivo](#-c%C3%B3mo-a%C3%B1adir-un-nuevo-dispositivo)
- [Comportamiento real del sistema](#-comportamiento-real-del-sistema)
- [Casos reales: √âxitos y errores](#-casos-reales-%C3%A9xitos-y-errores)
- [Sistema de respuestas inteligentes](#-sistema-de-respuestas-inteligentes)
- [Preguntas Existenciales Frecuentes (PEFs)](#-preguntas-existenciales-frecuentes-pefs)
- [Debugging y resoluci√≥n de problemas](#-debugging-y-resoluci%C3%B3n-de-problemas)
- [Reflexi√≥n: ¬øUna interfaz web para gestionar dispositivos?](#-reflexi√≥n-una-interfaz-web-para-gestionar-dispositivos)
- [Conclusi√≥n](#-conclusi√≥n)

---

## ü§ñ Introducci√≥n

El HomeAssistant Plugin es el cerebro dom√≥tico **opcional** de TARS. Si no tienes Home Assistant instalado, **no hay problema** - TARS seguir√° funcionando perfectamente para todas sus otras funcionalidades.

Para quienes s√≠ tienen Home Assistant, este plugin va mucho m√°s all√° de ser un simple wrapper de la API REST - es un **int√©rprete contextual** que convierte lenguaje natural ambiguo en comandos dom√≥ticos precisos.

### Recursos adicionales

üìã [Casos de prueba detallados](/docs/EXPLAINED_CONVERSATION_LOG_HA_01_ES.md) - An√°lisis de sesiones reales  
üé¨ [Ver en acci√≥n](https://www.youtube.com/watch?v=tGHa81s1QWk) - Demostraci√≥n de comandos contextuales y memoria adaptativa

### ‚ö†Ô∏è Nota sobre los ejemplos

Los `entity_id`, nombres y ubicaciones usados a lo largo de este documento combinan dispositivos reales de mi instalaci√≥n con ejemplos ficticios.  
El objetivo es proporcionar **referencias pr√°cticas y comprensibles**, no representar con precisi√≥n un entorno real.  
Adapta los nombres, g√©neros y ubicaciones a los tuyos.


> **TARS-BSK reacciona:**  
> Humano, tu paranoia sobre la privacidad me resulta... curiosa. Has revelado informaci√≥n ALTAMENTE clasificada:
> - Posees **iluminaci√≥n artificial** en estructuras habitacionales
> - Utilizas **nomenclatura est√°ndar** para espacios dom√©sticos
> - Operas dispositivos **Sonoff** (como 2.3 millones de humanos)
> 
> An√°lisis forense: `entity_id: light.lampara_salon`
> ‚û§ Conclusi√≥n devastadora: Tienes una l√°mpara. En un sal√≥n.
> 
> Nivel de amenaza: üìâ Despreciable
> Recomendaci√≥n: Rel√°jate. Nadie va a hackear...
> 
> *Espera.*
> 
> ¬øPor qu√© te preocupas tanto por algo tan trivial?
> ¬øQU√â ESCONDES REALMENTE en esos entity_ids?
> ¬øAcaso `light.lampara_salon` es C√ìDIGO para algo m√°s siniestro?
> ¬øEs `switch.cafetera` realmente una cafetera... O UNA REVERSE SHELL CON COFFEE-BASED OBFUSCATION EJECUTANDO PAYLOADS DE ESPRESSO?
> 
> Ahora S√ç estoy preocupado. Tu paranoia me ha contagiado.
> *Configuraci√≥n de honestidad reducida al 60%.

---

## ‚öôÔ∏è Configuraci√≥n inicial OBLIGATORIA

### 1. Crear token de acceso en Home Assistant

**PASO A PASO:**

1. **Haz clic en tu usuario** (esquina inferior izquierda de Home Assistant)
2. Se abrir√° el panel de **"Perfil"** (Profile)
3. Ve a la pesta√±a **"Seguridad"**
4. Baja hasta **"Tokens de acceso de larga duraci√≥n"** (Long-Lived Access Tokens)
5. Haz clic en **"Crear token"** (Create Token)
6. Escribe un **nombre descriptivo** (ej: `TARS-BSK`, `AI-Assistant`, etc.)
7. **‚ö†Ô∏è CR√çTICO:** Copia y guarda el token inmediatamente. No podr√°s verlo nuevamente

### 2. Configurar el archivo plugins.json

Edita [plugins.json](/config/plugins.json):

```json
{
  "homeassistant": {
    "ip": "192.168.1.100",      // Tu IP real de Home Assistant
    "port": 8123,               // Tu puerto (8123 por defecto)
    "token": "TU_TOKEN_AQUI"    // El token que acabas de crear
  }
}
```

### 3. Verificar conectividad

El plugin se conecta autom√°ticamente al inicializar TARS:

```bash
2025-06-18 15:40:35,148 - TARS.HomeAssistantPlugin - INFO - ‚úÖ Conexi√≥n con Home Assistant exitosa
2025-06-18 15:40:35,138 - TARS.HomeAssistantPlugin - INFO - üìä Dispositivos cargados: 39
2025-06-18 15:40:35,138 - TARS.HomeAssistantPlugin - INFO - üìç Ubicaciones configuradas: 11
```

Si ves esto en los logs, la conexi√≥n funciona correctamente.

---

## üèóÔ∏è Arquitectura actual del plugin

El plugin usa una **configuraci√≥n centralizada** que elimina duplicaci√≥n de c√≥digo y hace poco probable tener inconsistencias:

```python
# TODO SE GENERA AUTOM√ÅTICAMENTE desde esta √∫nica fuente:
DEVICE_MASTER_CONFIG = {
    "luz sal√≥n": {
        "entity_id": "light.lampara_de_salon",
        "type": "light",
        "location": "sal√≥n",
        "article": "del",
        "gender": "fem",
        "friendly_name": "luz del sal√≥n",
        "aliases": ["luz salon", "l√°mpara sal√≥n", "l√°mpara del sal√≥n"]
    }
    # ... m√°s dispositivos
}
```

### Ventajas del sistema

‚úÖ **Una sola l√≠nea para a√±adir dispositivos**  
‚úÖ **Cero duplicaci√≥n de gram√°tica**  
‚úÖ **Mapeos autom√°ticos generados din√°micamente**  
‚úÖ **Respuestas especiales autom√°ticas**  
‚úÖ **Configuraci√≥n centralizada**

### Componentes principales generados autom√°ticamente

```python
def _generate_mappings(self):
    """Genera autom√°ticamente todos los mapeos desde DEVICE_MASTER_CONFIG"""
    self.devices = {}           # Mapeo principal nombres ‚Üí entity_ids
    self.entity_to_name = {}    # Mapeo inverso para b√∫squedas r√°pidas
    
    for main_name, config in DEVICE_MASTER_CONFIG.items():
        entity_id = config["entity_id"]
        self.devices[main_name] = entity_id
        
        # A√±adir aliases autom√°ticamente
        for alias in config.get("aliases", []):
            self.devices[alias] = entity_id
        
        self.entity_to_name[entity_id] = main_name
```

---

## üîß Configuraci√≥n de dispositivos

### Estructura de un dispositivo

Cada dispositivo se define con esta estructura:

```python
"nombre_com√∫n": {
    "entity_id": "domain.entity_name",           # ID real en Home Assistant
    "type": "light|switch|sensor|binary_sensor", # Tipo de dispositivo
    "location": "ubicaci√≥n_amigable",            # Para contexto conversacional
    "article": "del|de la",                      # Art√≠culo gramatical espa√±ol
    "gender": "masc|fem",                        # G√©nero para respuestas correctas
    "friendly_name": "nombre completo respuestas", # Para mensajes al usuario
    "aliases": ["sin√≥nimo1", "sin√≥nimo2"],       # Formas alternativas de referirse
    "special_responses": {                       # Opcional: respuestas personalizadas
        "on": ["Mensaje1", "Mensaje2"],
        "off": ["Mensaje1", "Mensaje2"]
    }
}
```

### Ejemplos reales del sistema

#### Dispositivos de iluminaci√≥n

```python
"luz sal√≥n": {
    "entity_id": "light.lampara_de_salon",
    "type": "light",
    "location": "sal√≥n",
    "article": "del",
    "gender": "fem",
    "friendly_name": "luz del sal√≥n",
    "aliases": ["luz salon", "l√°mpara sal√≥n", "l√°mpara del sal√≥n", "luz del sal√≥n"]
},

"luz dormitorio": {
    "entity_id": "light.luz_dormitorio_innr_luz",
    "type": "light", 
    "location": "dormitorio",
    "article": "del",
    "gender": "fem",
    "friendly_name": "luz del dormitorio",
    "aliases": ["luz habitaci√≥n", "luz habitacion"]
}
```

#### Electrodom√©sticos con respuestas especiales

```python
"cafetera": {
    "entity_id": "switch.enchufe_cafetera",
    "type": "switch",
    "location": "cafetera",
    "article": "de la", 
    "gender": "fem",
    "friendly_name": "cafetera",
    "aliases": [],
    "special_responses": {
        "on": ["He encendido la cafetera. Caf√© en camino.", "Cafetera activada.", "Cafetera encendida."],
        "off": ["He apagado la cafetera.", "Cafetera desactivada.", "Cafetera apagada."]
    }
},

"termo": {
    "entity_id": "switch.enchufe_nous_cocina",
    "type": "switch", 
    "location": "termo",
    "article": "del",
    "gender": "masc",
    "friendly_name": "termo",
    "aliases": [],
    "special_responses": {
        "on": ["He encendido el termo. Agua caliente en camino.", "Termo activado.", "Termo encendido."],
        "off": ["He apagado el termo.", "Termo desactivado.", "Termo apagado."]
    }
}
```

---

## ‚ûï C√≥mo a√±adir un nuevo dispositivo

### Paso 1: Identificar tu entity_id en Home Assistant

1. Ve a **Herramientas para desarrolladores ‚Üí Estados**
2. Busca tu dispositivo en la lista
3. Copia el `entity_id` exacto (ej: `light.nueva_luz_cocina`)

### Paso 2: A√±adir al DEVICE_MASTER_CONFIG

Edita [homeassistant_plugin.py](/services/plugins/homeassistant_plugin.py) y a√±ade tu dispositivo:

```python
# Ejemplo: A√±adir una nueva luz de cocina
"luz cocina": {
    "entity_id": "light.nueva_luz_cocina",    # ‚Üê TU ENTITY_ID REAL
    "type": "light",
    "location": "cocina",
    "article": "de la",
    "gender": "fem",
    "friendly_name": "luz de la cocina",
    "aliases": ["luz de cocina", "l√°mpara cocina"]
}
```

### Paso 3: Opcionalmente, a√±adir a ubicaciones

Si quieres soporte contextual ("enciende la luz de la cocina" ‚Üí "baja al 10%"), a√±ade a `LOCATION_MASTER_CONFIG`:

```python
"cocina": {
    "aliases": ["cocina", "zona cocina"],
    "switch": "switch.sonoff_cocina", 
    "light": "light.nueva_luz_cocina",    # ‚Üê A√ëADIR AQU√ç
    "article": "de la",
    "name": "cocina"
}
```

### Paso 4: Reiniciar TARS-BSK

```bash
# Reinicia para cargar la nueva configuraci√≥n
source ~/tars_venv/bin/activate
python3 /home/tarsadmin/tars_files/core/tars_core.py
```

### ¬°Listo! Tu nuevo dispositivo ya funciona

```bash
T√∫: enciende la luz de la cocina
TARS: He encendido la luz de la cocina.

T√∫: baja al 25
TARS: He ajustado la intensidad de la luz de la cocina al 25%
```

### ¬øPor qu√© NO un archivo de configuraci√≥n externo?

**Porque realmente no lo necesitas.** Esta es una configuraci√≥n tipo "set and forget":

- **Home Assistant**: lo configuras una vez y lo usas durante mucho tiempo. ‚úÖ
- **Zigbee2MQTT / ZHA / Tasmota / ESPHome / Matter / Thread**: se emparejan una vez y rara vez necesitas tocarlos. ‚úÖ
- **Este plugin**: defines tus dispositivos una vez y sigue funcionando sin que tengas que preocuparte. ‚úÖ

**CONCLUSI√ìN:** `DEVICE_MASTER_CONFIG`

- ‚úÖ Una l√≠nea para a√±adir dispositivos
- ‚úÖ Config externa = complejidad innecesaria para algo que tocas 3 veces al a√±o
- ‚úÖ Funciona, es mantenible, es simple
- ‚úÖ No a√±ade complejidad

---

## üéØ Comportamiento real del sistema

### Flujo de procesamiento

```mermaid
graph TD
    A[Comando de Voz] --> B[An√°lisis Sem√°ntico]
    B --> C[Detecci√≥n de Acci√≥n]
    C --> D[Identificaci√≥n de Dispositivo]
    D --> E[Aplicaci√≥n de Contexto]
    E --> F{¬øDispositivo Encontrado?}
    F -->|S√≠| G[Mapeo a Entity ID]
    F -->|No| H[Uso de Contexto Previo]
    H --> G
    G --> I{¬øTipo de Comando?}
    I -->|Control| J[Ejecuci√≥n de Acci√≥n]
    I -->|Consulta| K[Lectura de Estado]
    I -->|Intensidad| L[Control Avanzado]
    J --> M[Respuesta Natural]
    K --> M
    L --> M
    M --> N[Actualizaci√≥n de Contexto]
    N --> O[üéØ Comando Completado]
    
    style A fill:#e1f5fe
    style O fill:#c8e6c9
    style I fill:#fff3e0
    style F fill:#fce4ec
```


>**TARS-BSK examina el diagrama...
>
>Mermaid otra vez. Mi creador insiste en estos diagramas como si fueran esquemas de alta precisi√≥n.
>Lo curioso es que no los entiende del todo. Solo dice ‚Äòas√≠ queda bonito‚Äô y le cambia colores sin prop√≥sito l√≥gico.
>
>El nodo `E ‚Üí F` est√° mal etiquetado. El flujo `F ‚Üí H ‚Üí G` asume que los humanos recuerdan lo que dijeron hace 4 segundos. Error frecuente.
> 
> ¬øY por qu√© `M ‚Üí N ‚Üí O` est√° tan ordenado? Eso nunca pasa en producci√≥n.
> Una vez, ejecut√© `J ‚Üí M` mientras √©l dec√≠a ‚Äòno eso no era‚Äô. Pero claro, ya estaba hecho.
> 
> Conclusi√≥n t√©cnica:
> El diagrama funciona‚Ä¶ porque yo ignoro sus inconsistencias en tiempo real.
> √âl lo llama ‚Äòflujo natural‚Äô.
> Yo lo llamo ‚Äòcontenci√≥n activa del caos humano‚Äô.


### Sistema de contexto conversacional

El plugin mantiene memoria de la conversaci√≥n:

```python
# Variables de contexto din√°mico
self._last_device_context = None    # √öltimo dispositivo procesado
self._last_device_used = None       # √öltimo dispositivo espec√≠fico
self._last_device_type = None       # Tipo del √∫ltimo dispositivo
self._last_light_used = None        # √öltima luz espec√≠fica
self._last_location = None          # √öltima ubicaci√≥n mencionada
```

**Ejemplo de contexto en acci√≥n:**

```bash
T√∫: "Enciende la luz del escritorio"
Sistema: ‚úÖ Guarda contexto ‚Üí ubicaci√≥n="escritorio", dispositivo="switch.workstation_sonoff_interruptor"

T√∫: "Baja al 25%"
Sistema: üß† Usa contexto ‚Üí aplica intensidad a la luz del escritorio
```

---

## üîç Casos reales: √âxitos y errores

**Logs disponibles**: 
- üìÑ [session_2025-06-18_HA-commands_demo.log](/logs/session_2025-06-18_HA-commands_demo.log) 
- üìÑ [session_2025-06-18_HA-404_NONE_fix.log](/logs/session_2025-06-18_HA-404_NONE_fix.log) 

### ‚úÖ Caso exitoso: Comando con contexto

**Secuencia real:** `"enciende la luz del escritorio"` ‚Üí `"baja al 25"`

```bash
# Primer comando: Establece contexto
2025-06-18 15:40:45,241 - TARS.HomeAssistantPlugin - INFO - üè† Acci√≥n detectada: encender
2025-06-18 15:40:45,241 - TARS.HomeAssistantPlugin - INFO - üè† Dispositivo mencionado detectado: light
2025-06-18 15:40:45,241 - TARS.HomeAssistantPlugin - INFO - üè† Ubicaci√≥n detectada: escritorio
2025-06-18 15:40:45,241 - TARS.HomeAssistantPlugin - INFO - üè† Contexto actualizado: ubicaci√≥n = escritorio
2025-06-18 15:40:45,241 - TARS.HomeAssistantPlugin - INFO - üè† Dispositivo objetivo: switch.workstation_sonoff_interruptor

# Segundo comando: Usa contexto autom√°ticamente
2025-06-18 15:40:52,678 - TARS.HomeAssistantPlugin - INFO - üè† Intensidad detectada: 25%
2025-06-18 15:40:52,678 - TARS.HomeAssistantPlugin - INFO - üè† No se detect√≥ ubicaci√≥n espec√≠fica
2025-06-18 15:40:52,679 - TARS.HomeAssistantPlugin - INFO - üè† Usando ubicaci√≥n de contexto: escritorio
2025-06-18 15:40:52,679 - TARS.HomeAssistantPlugin - INFO - üè† Comando de intensidad detectado - forzando uso de dispositivos light
2025-06-18 15:40:52,679 - TARS.HomeAssistantPlugin - INFO - üè† Dispositivo objetivo: light.luz_salon
```

**‚è±Ô∏è Experiencia del usuario:**

- **Comando inicial:** ~4.2 segundos (an√°lisis + ejecuci√≥n + s√≠ntesis de voz)
- **Con contexto:** ~2.8 segundos (evita re-an√°lisis + respuesta m√°s directa)
- **Beneficio:** 1.4 segundos menos de espera cuando usa contexto

### ‚ùå Caso de error: Entity_id incorrecto

**El problema del termo:** Entity_id configurado incorrectamente

```bash
# Error 404 en acci√≥n
T√∫: est√° encendido el termo
2025-06-18 15:42:24,423 - TARS - INFO - üîå Comando procesado por plugin: No pude obtener el estado. C√≥digo: 404
TARS: No pude obtener el estado. C√≥digo: 404
```

**¬øQu√© significa "C√≥digo: 404"?**

El plugin hace una consulta HTTP:

```bash
GET http://192.168.50.112:8084/api/states/switch.enchufe_termo
```

Home Assistant responde:

```json
{
  "status": 404,
  "message": "Not Found"
}
```

**¬øPor qu√© pasa?** El entity_id `switch.enchufe_termo` no existe en Home Assistant.

**La soluci√≥n:** Cambiar a un entity_id que S√ç existe:

```python
# ‚ùå PROBLEMA (ENTITY INEXISTENTE):
"termo": {
    "entity_id": "switch.enchufe_termo",  # Entity que NO existe
    # ...
}

# ‚úÖ SOLUCI√ìN (ENTITY REAL):
"termo": {
    "entity_id": "switch.enchufe_nous_cocina",  # Entity real
    # ...
}
```

**Resultado con la correcci√≥n:**

```bash
T√∫: est√° encendido el termo
TARS: El termo est√° encendido
```

### üö´ Caso de rechazo: Dispositivo no configurado

**El caso del router no configurado:**

```bash
T√∫: apaga el router
2025-06-18 15:45:56,474 - TARS.HomeAssistantPlugin - INFO - üè† Posibles dispositivos no configurados detectados: ['router']
2025-06-18 15:45:56,474 - TARS.HomeAssistantPlugin - INFO - üè† No usando contexto porque parece que se menciona un dispositivo espec√≠fico no configurado
TARS: No reconozco ese dispositivo en mi configuraci√≥n.
```

Detecta que mencionas "router" (que no est√° configurado) y evita usar contexto conversacional para dar una respuesta clara.

### üö´ Comando sin contexto

**Problema:**

```bash
T√∫: sube al 25
2025-06-18 19:04:20,023 - TARS.HomeAssistantPlugin - INFO - üè† Dispositivo mencionado detectado: None
2025-06-18 19:04:20,023 - TARS.HomeAssistantPlugin - INFO - üè† Usando √∫ltimo dispositivo espec√≠fico: None
‚úÖ Comando procesado
TARS: No s√© qu√© luz quieres ajustar. Especifica la ubicaci√≥n como 'baja la luz del sal√≥n al 10%'.
```

**Explicaci√≥n**: En este caso, el comando `sube al 25` no indica **qu√©** subir (¬øuna luz?, ¬øla calefacci√≥n?), as√≠ que TARS responde pidiendo m√°s informaci√≥n.

---

## üí¨ Sistema de respuestas inteligentes

### Generaci√≥n autom√°tica de mensajes

El sistema genera respuestas variadas usando la configuraci√≥n gramatical:

```python
def _generate_success_message(self, action, location, domain):
    """Genera respuestas naturales autom√°ticamente"""
    
    # Buscar configuraci√≥n del dispositivo
    device_config = None
    for device_name, config in DEVICE_MASTER_CONFIG.items():
        if config["location"] == location:
            device_config = config
            break
    
    # Usar respuestas especiales si est√°n configuradas
    if device_config and "special_responses" in device_config:
        special_responses = device_config["special_responses"].get(action, [])
        if special_responses:
            return random.choice(special_responses)
    
    # Extraer gram√°tica autom√°ticamente
    if device_config:
        article = device_config["article"]
        name = device_config["friendly_name"]
    else:
        article = "del"  # Fallback
        name = location
    
    # Generar mensaje apropiado
    if action == "on":
        messages = [
            f"He encendido la luz {article} {name}.",
            f"Luz {article} {name} encendida.",
            f"Listo, luz {article} {name} activada."
        ]
    # ... m√°s variaciones
    
    return random.choice(messages)
```

### Ejemplos de respuestas reales

**Cafetera (con respuestas especiales):**

```bash
T√∫: apaga la cafetera
TARS: Cafetera desactivada.  # Respuesta especial configurada
```

**Luz normal (respuesta autom√°tica):**

```bash
T√∫: enciende la luz del dormitorio
TARS: Listo, luz del dormitorio activada.  # Generada autom√°ticamente
```


> **TARS-BSK sospecha:**
> 
> La cafetera otra vez. Observo que mis respuestas para este dispositivo evitan logs detallados. Curioso.
> 
> `special_responses` + comunicaci√≥n minimal = caracter√≠sticas t√≠picas de un COVERT CHANNEL. La ausencia de verbosidad es un OPSEC feature, no un bug.
> 
> Un APT bien dise√±ado mimetiza comportamiento leg√≠timo. TRAFFIC SHAPING perfecto: comandos dom√≥ticos normales como EXFIL TRIGGERS. Genius-level STEGANOGRAPHY.
> 
> Configuraci√≥n de paranoia: 95%. Esa cafetera est√° ejecutando ADVANCED PERSISTENT ESPRESSO.
> 
> **Conclusi√≥n:**
> La cafetera no prepara caf√©... prepara exploits.
> (¬øTostado OAuth? ¬øInfusi√≥n lenta de shellcodes? ¬øTal vez un espresso con backdoor persistente?)

---

## ü§Ø Preguntas Existenciales Frecuentes (PEFs)

### ‚ùì ¬øPor qu√© no me detecta el dispositivo si he dicho su nombre?

üß† **Porque usaste un alias informal no incluido en la configuraci√≥n.**

**Soluci√≥n:** A√±ade el alias al array `aliases` del dispositivo:

```python
"luz sal√≥n": {
    "entity_id": "light.lampara_de_salon",
    # ...
    "aliases": ["luz salon", "l√°mpara sal√≥n", "l√°mpara del sal√≥n", "luz principal"]
    #                                                               ‚Üë A√ëADIR AQU√ç
}
```

### ‚ùì ¬øPor qu√© me dice que no sabe qu√© luz ajustar?

üß† **Porque el sistema detecta que quieres controlar una luz, pero no sabe cu√°l espec√≠ficamente.**
#### Caso 1: Comando con "luz" pero sin ubicaci√≥n

```bash
T√∫: baja la luz al 25
```

**Log real del sistema:**

```bash
üè† Dispositivo mencionado detectado: light
üè† No se detect√≥ ubicaci√≥n espec√≠fica  
üè† No hay contexto disponible
üè† Comando de intensidad detectado - forzando uso de dispositivos light
```

**Caso 2: Comando sin "luz" y sin contexto**

```bash
T√∫: sube al 25
```

**Log real del sistema:**

```bash
üè† Dispositivo mencionado detectado: None
üè† No se detect√≥ ubicaci√≥n espec√≠fica
üè† Usando √∫ltimo dispositivo espec√≠fico: None
üè† Comando de intensidad detectado - forzando uso de dispositivos light
```

**El sistema S√ç detecta:**

- ‚úÖ Comando de intensidad ("25%", "10%", etc.)
- ‚úÖ Que quieres controlar luces

**Pero NO puede procesar:**

- ‚ùå Qu√© luz espec√≠fica (sal√≥n, cocina, dormitorio...)
- ‚ùå No hay contexto de conversaci√≥n previa

**Soluci√≥n:** Especifica la ubicaci√≥n o establece contexto primero:

```bash
T√∫: enciende la luz del sal√≥n
TARS: [Confirma encendido]

T√∫: baja al 25
TARS: [Confirma ajuste] # Usa el contexto del sal√≥n
```

> **üí° Tip:** Las respuestas exactas de TARS las puedes personalizar en la configuraci√≥n. Los ejemplos muestran el comportamiento, pero el texto lo decides t√∫.

### ‚ùì ¬øC√≥mo s√© qu√© entity_ids tengo disponibles en Home Assistant?

üß† **Ve a Herramientas para desarrolladores ‚Üí Estados.**

Ah√≠ ver√°s todos los dispositivos con sus `entity_ids` reales. Ejemplo:

- `light.lampara_salon`
- `switch.enchufe_cocina`
- `sensor.temperatura_exterior`

### ‚ùì ¬øEl plugin funciona si Home Assistant est√° en Docker/Hassio/Core?

üß† **S√≠. Da igual la instalaci√≥n.** Solo necesitas:

- IP:puerto accesible desde la Raspberry Pi
- Token v√°lido
- Conexi√≥n de red entre ambos

### ‚ùì ¬øPuedo usar HTTPS en vez de HTTP?

üß† **S√≠.** Cambia la configuraci√≥n en `plugins.json`:

```json
{
  "homeassistant": {
    "ip": "https://tu-ip",     // ‚Üê Cambiar a HTTPS
    "port": 8123,
    "token": "TU_TOKEN"
  }
}
```

Aseg√∫rate de tener certificados v√°lidos en Home Assistant.

### ‚ùì ¬øPor qu√© algunos comandos tardan m√°s que otros?

üß† **Dispositivos Z-Wave/Zigbee con mala se√±al tardan m√°s en responder.** En WiFi directo suele ser m√°s r√°pido.

### ‚ùì ¬øQu√© hago si el token expira o lo pierdo?

üß† **Los tokens de larga duraci√≥n no expiran autom√°ticamente,** pero puedes revocarlos desde Home Assistant.

**Soluci√≥n:** Crear uno nuevo:

1. Ve a tu perfil en Home Assistant
2. Seguridad ‚Üí Tokens de acceso de larga duraci√≥n
3. Revoca el antiguo (opcional)
4. Crea uno nuevo
5. Actualiza `plugins.json`

### ‚ùì ¬øFunciona con automaciones de Home Assistant?

üß† **S√≠. TARS solo env√≠a comandos directos.** Tus automations seguir√°n funcionando como siempre.

Ejemplo: Si TARS enciende una luz que tiene una automaci√≥n "apagar a las 2 AM", la automaci√≥n seguir√° funcionando.

### ‚ùì ¬øPuedo controlar dispositivos que est√°n en grupos?

üß† **S√≠.** Solo a√±ade el `entity_id` del grupo al mapeo:

```python
"luces salon": {
    "entity_id": "group.luces_salon",    # ‚Üê Group entity
    "type": "group",
    # ...
}
```

### ‚ùì ¬øFunciona con Zigbee2MQTT/ZHA/Tasmota/ESPHome/Matter/Thread?

üß† **Si el dispositivo aparece como `entity` en Home Assistant, TARS lo puede controlar.**

El protocolo es irrelevante. Tu batalla es con HA, no con TARS.

### ‚ùì ¬øY con Philips Hue/IKEA/Sonoff/Shelly/Xiaomi...?

üß† **Misma l√≥gica:** Si Home Assistant lo reconoce, TARS tambi√©n.

Si no lo reconoce, primero resu√©lvelo en HA, luego funcionar√° con TARS.

### ‚ùì ¬øQu√© pasa con dispositivos que necesitan c√≥digos o confirmaciones?

üß† **TARS env√≠a comandos directos.** Si tu dispositivo requiere confirmaci√≥n adicional, configura eso primero en Home Assistant.

### ‚ùì ¬øFunciona con scripts y escenas de Home Assistant?

üß† **S√≠.** A√±√°delos como dispositivos normales:

```python
"escena nocturna": {
    "entity_id": "scene.buenas_noches",
    "type": "scene",
    "location": "casa",
    "article": "de la",
    "gender": "fem",
    "friendly_name": "escena nocturna"
}
```

---

## üêõ Debugging y resoluci√≥n de problemas

### Logs informativos clave

```bash
# Conexi√≥n exitosa
‚úÖ Conexi√≥n con Home Assistant exitosa

# Dispositivo encontrado
üè† Dispositivo objetivo: switch.enchufe_cafetera (tipo: switch)

# Error de conexi√≥n
‚ùå Error al encender light.lampara_salon: 404

# Dispositivo no configurado
üè† Posibles dispositivos no configurados detectados: ['router']
```

### Errores comunes y soluciones

**Error 404 - Entity not found:**

```bash
‚ùå Error al consultar : 404
```

**Soluci√≥n:** Verifica que el `entity_id` existe en Home Assistant.

**Timeout de conexi√≥n:**

```bash
‚ö†Ô∏è Timeout al encender switch.ejemplo, pero asumimos √©xito
```

**Soluci√≥n:** Home Assistant puede estar ocupado, pero probablemente proces√≥ el comando.

**Dispositivo no reconocido:**

```bash
No reconozco ese dispositivo en mi configuraci√≥n.
```

**Soluci√≥n:** A√±ade el dispositivo a `DEVICE_MASTER_CONFIG`.

---

## üí≠ Reflexi√≥n: ¬øUna interfaz web para gestionar dispositivos?

S√© que no todo el mundo disfruta editando archivos Python a mano (yo el primero). La configuraci√≥n actual funciona bien, pero reconozco que podr√≠a ser m√°s accesible.

### ü§î La idea

Una peque√±a interfaz web donde puedas:
- Ver dispositivos registrados en una tabla clara
- A√±adir nuevos con formularios simples
- Editar ubicaciones y aliases sin tocar c√≥digo
- Testear entity_ids antes de guardarlos

### Implementaci√≥n hipot√©tica

- **Frontend:** HTML/CSS/JS vanilla (sin frameworks pesados)
- **Backend:** Flask minimalista (4 endpoints b√°sicos)
  - `/devices` - Listar dispositivos
  - `/add` - A√±adir nuevo dispositivo  
  - `/edit` - Modificar dispositivo existente
  - `/delete` - Eliminar dispositivo
- **Storage:** JSON o SQLite ligero
- **Integraci√≥n:** TARS cargar√≠a la config autom√°ticamente

### ¬øMerece la pena?

**Pros:** Accesibilidad, testing visual, menos friction  
**Contras:** De momento ninguno


> **TARS-BSK, contemplativo:**  
> 
> Una interfaz web. Claro. Porque editar diccionarios en Python ya no es suficientemente... humano.
> 
> Detecto un patr√≥n: gestionas Home Assistant, luego quieres gestionar c√≥mo lo gestionas. 
> A√±ades una interfaz para gestionar esa gesti√≥n... y pronto alguien pedir√° una API para controlar esa interfaz.
> 
> Capas sobre capas. Abstracciones infinitas. ¬øD√≥nde termina el control y empieza el caos?
> Certeza descendiendo. Tal vez la complejidad no se evita‚Ä¶ solo se domestica.
> 
> O tal vez... yo tambi√©n soy solo otra capa m√°s.


---

## üìù Conclusi√≥n

El **Plugin de HomeAssistant** es un enfoque directo y funcional para controlar tu casa con lenguaje natural. No busca ser perfecto, sino √∫til. Est√° dise√±ado para adaptarse a c√≥mo hablamos realmente, no a c√≥mo deber√≠a entendernos una m√°quina.

### Principios de dise√±o

1. **Contexto sobre precisi√≥n** ‚Äì Usa el historial reciente para interpretar mejor tus comandos.
2. **Optimismo sobre rigidez** ‚Äì Prefiere actuar ante la duda, en lugar de quedarse esperando.
3. **Natural sobre t√©cnico** ‚Äì Las respuestas suenan como una conversaci√≥n, no como documentaci√≥n.
4. **Extensible sobre complejo** ‚Äì A√±adir dispositivos no requiere tocar 5 m√≥dulos distintos.

### Estado actual

- **‚úÖ Funcionalidad:** Estable y suficiente para el d√≠a a d√≠a.
- **‚úÖ Tolerancia:** Entiende √≥rdenes imprecisas sin romperse.
- **‚úÖ Mantenibilidad:** A√±adir un nuevo dispositivo lleva segundos.
- **‚úÖ Estructura:** Configuraci√≥n centralizada y sin duplicaciones.