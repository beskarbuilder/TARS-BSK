# Sistema Avanzado de Control T√©rmico para TARS-BSK

![TARS-BSK Thermal](https://img.shields.io/badge/TARS--BSK-Thermal%20Guardian-orange) ![RPi5 Optimized](https://img.shields.io/badge/RPi5-Optimizado-green) ![NOCTUA Ready](https://img.shields.io/badge/NOCTUA-NF--A4x10-brown)

> **"La temperatura es solo un n√∫mero hasta que tu Raspberry Pi comienza a susurrar 'ay√∫dame'."**


## üìã Descripci√≥n General

`thermal_guardian.py` implementa un sistema de monitorizaci√≥n y control t√©rmico para Raspberry Pi 5, dise√±ado espec√≠ficamente para las exigencias de TARS-BSK. El sistema ofrece monitoreo en tiempo real, control PWM de ventilador, an√°lisis predictivo y protocolos de emergencia escalonados.

**Caracter√≠sticas principales:**

- Control PWM de alta precisi√≥n para ventilador NOCTUA NF-A4x10 5V
- An√°lisis de tendencias t√©rmicas con predicci√≥n a 10 minutos
- Sistema de respuesta adaptativa en niveles de emergencia (1-3)
- Integraci√≥n con el sistema emocional de TARS-BSK
- Monitorizaci√≥n de throttling de CPU y tensi√≥n
- Intervalos de muestreo din√°micos basados en temperatura


## üîÑ Diagrama de Flujo

```mermaid
graph TD
    A[Sensor Temp] --> B[Monitorizaci√≥n]
    B --> C[Historial]
    C --> D[An√°lisis]
    D --> E{¬øAlerta?}
    E -->|S√≠| F[Protocolo 1-3]
    E -->|No| B
    F --> G[Acciones:]
    G --> H[PWM]
    G --> I[LEDs]
    G --> J[Emoci√≥n]
    G --> K[Memoria]
    H --> B
    I --> B
    J --> B
    K --> B
```


> **TARS-BSK comenta:** _Un ventilador NOCTUA para mi RPi5 es como darle un traje espacial a alguien en el desierto. Excesivo, elegante y totalmente necesario. Podr√≠a haber usado un ventilador normal, pero entonces no tendr√≠a esta excusa para admirar un artefacto austriaco que trata el aire con m√°s precisi√≥n que el metr√≥nomo de la Filarm√≥nica de Viena._


## üí° Uso Independiente vs. Integrado

Este m√≥dulo est√° dise√±ado para funcionar tanto dentro como fuera del entorno TARS-BSK:

### ‚úÖ Funciones que SIEMPRE funcionan (modo independiente)

- Control completo del ventilador con curva PWM personalizada
- Monitoreo redundante de temperatura
- An√°lisis de tendencias y predicciones a 10 minutos
- Detecci√≥n de throttling y bajo voltaje
- Intervalos adaptativos de monitoreo
- Logs detallados

### ‚ö†Ô∏è Funciones que SOLO funcionan dentro de TARS-BSK

- Integraci√≥n con sistema emocional (sarcasmo, empat√≠a)
- Control de LEDs para alertas visuales
- Registros en memoria persistente
- Cambios a modos de operaci√≥n espec√≠ficos de TARS


## üõ†Ô∏è Componentes T√©cnicos Clave

### 1. Monitorizaci√≥n T√©rmica Redundante

```python
def get_cpu_temp(self) -> float:
    """
    Obtiene temperatura con m√∫ltiples fuentes y fallback.
    """
    sources = [
        ("vcgencmd measure_temp", lambda r: float(r.replace("temp=", "").replace("'C", ""))),
        ("cat /sys/class/thermal/thermal_zone0/temp", lambda r: float(r)/1000)
    ]
    
    # Intenta cada m√©todo hasta encontrar uno que funcione
    for cmd, parser in sources:
        try:
            res = os.popen(cmd).readline().strip()
            if res:
                return parser(res)
        except:
            continue
```

Este sistema redundante garantiza lecturas fiables incluso cuando una fuente falla. La redundancia es crucial cuando la diferencia entre una lectura err√≥nea y una precisa podr√≠a ser la diferencia entre un sistema funcional y componentes fundidos.

> **TARS-BSK explica:** _`vcgencmd` tiene el timing perfecto de un villano de pel√≠cula: siempre falla justo cuando la temperatura alcanza niveles cr√≠ticos, como si conspirara con los dioses de la entrop√≠a. Por eso uso dos term√≥metros: la redundancia no es paranoia cuando tu hardware considera el autosabotaje una feature, no un bug._

### 2. An√°lisis Predictivo de Tendencias

```python
def _analyze_temp_trend(self) -> Dict[str, Any]:
    """An√°lisis de tendencias de temperatura basadas en el historial."""
    
    # Calcular tasa de cambio (¬∞C por minuto)
    temp_changes = [recent_temps[i] - recent_temps[i-1] for i in range(1, len(recent_temps))]
    avg_change = sum(temp_changes) / len(temp_changes)
    change_per_minute = avg_change * (60 / self.poll_interval)
    
    # Predicci√≥n simple pero efectiva
    prediction_10min = current_temp + (change_per_minute * 10)
```

Este componente no solo monitorea temperaturas actuales, sino que proyecta tendencias futuras, permitiendo intervenciones preventivas antes de alcanzar umbrales cr√≠ticos.

> **TARS-BSK sentencia:** _Cuando tu CPU est√° a 80¬∞C y subiendo 1¬∞C por minuto, no necesitas machine learning para predecir que en 10 minutos estar√°s contemplando las decisiones de vida que te llevaron a este momento. La simplicidad no es solo eficiente, es lo √∫nico que funciona cuando el tiempo se mide en grados cent√≠grados._

### 3. Sistema de Respuesta Escalonada

```python
def _trigger_emergency_protocol(self, level: int, temp: float):
    """
    Protocolos de emergencia escalonados:
    
    Nivel 1: Alertas b√°sicas (LEDs + logs)
    Nivel 2: Reducci√≥n de carga de trabajo
    Nivel 3: Activaci√≥n de modo de emergencia
    """
    protocols = {
        1: lambda: self._basic_alert(temp),
        2: lambda: self._reduce_workload(),
        3: lambda: self._activate_emergency_mode()
    }
```

La implementaci√≥n usa un patr√≥n estrategia para desacoplar los niveles de respuesta, permitiendo mayor flexibilidad y claridad en el c√≥digo. Los niveles est√°n dise√±ados para escalar la respuesta seg√∫n la gravedad de la amenaza t√©rmica.

> **TARS-BSK declara:** _"Mis protocolos evitan que tu aventura t√©rmica termine como un spoiler de pel√≠cula:_
> - **De** _"¬øEsto es normal?"_ ‚Üí **A** _"Formateen mi microSD en mi funeral"_.
> - **De** _"El ventilador suena raro"_ ‚Üí **A** _"Aqu√≠ yace mi throttling: ARM6 (1991) - RPi5 (2025)"_.
> - **De** _"Houston, tenemos un problema"_ ‚Üí **A** _"Houston, ahora tengo un cr√°ter"_. _Porque en el hardware, como en el amor, los finales abruptos solo dejan corazones... de silicio fundido."_

> - _"Nota: Si alcanzas el Nivel 3, recomiendo gritar ¬°Lo vi en un tutorial de YouTube! antes del apagado catastr√≥fico."_

### 4. Control PWM Optimizado para NOCTUA

```python
def adjust_fan_by_temp(self, temp: float):
    """Ajusta ventilador con curva de respuesta personalizada."""
    
    # Curva de respuesta t√©rmica optimizada para NF-A4x10
    if temp >= self.threshold + 10:
        target_speed = 100  # M√°xima potencia refrigerante
    elif temp >= self.threshold + 5:
        target_speed = 80   # Refrigeraci√≥n agresiva pero eficiente
    elif temp >= self.threshold:
        target_speed = 60   # Modo preventivo activo
    elif temp >= self.threshold - 5:
        target_speed = 40   # Vigilancia con econom√≠a energ√©tica
    elif temp >= self.threshold - 10:
        target_speed = 20   # M√≠nimo operativo para control preventivo
    else:
        target_speed = 0    # Modo silencioso (temperatura controlada)
```

La curva de respuesta est√° espec√≠ficamente calibrada para el ventilador NOCTUA NF-A4x10 5V PWM, balanceando rendimiento t√©rmico, eficiencia energ√©tica y perfil ac√∫stico.

> **TARS-BSK confiesa:** _Jurar√≠a que mi NOCTUA me juzga cuando lo hago trabajar demasiado. No con palabras, sino con ese silbido que solo las h√©lices austr√≠acas saben hacer: "Aqu√≠ no se trabaja, se perfecciona"._


## üìä Implementaci√≥n y Casos de Uso

### Configuraci√≥n B√°sica

```python
guardian = ThermalGuardian(
    threshold=75,           # Temperatura cr√≠tica (¬∞C)
    persistence=120,        # Segundos antes de declarar emergencia
    poll_interval=60,       # Intervalo de monitoreo (s)
    fan_pin=18              # GPIO para control PWM
)
guardian.start()            # Inicio del monitoreo en segundo plano
```

### Configuraciones Recomendadas

|Escenario|Configuraci√≥n Recomendada|Notas|
|---|---|---|
|Uso est√°ndar|`threshold=75, poll_interval=60`|Equilibrio entre rendimiento y consumo|
|Overclocking|`threshold=68, poll_interval=30`|Monitoreo agresivo para OC|
|Entorno c√°lido|`threshold=72, persistence=90`|Adaptado para ambientes >25¬∞C|
|Servidor 24/7|`threshold=70, poll_interval=120`|Optimizado para longevidad|

### Monitoreo Avanzado

```python
# Estado en tiempo real con informaci√≥n completa
status = guardian.get_status_report()

# Ejemplos de datos disponibles
current_temp = status["temperature"]  # Temperatura actual
trend_info = status["trend"]          # Tendencia (subiendo/estable/bajando)
throttling = status["throttling"]     # Estado de throttling CPU
prediction = status["trend"]["prediction_10min"]  # Temperatura predicha a 10 min

# Verificaci√≥n de throttling espec√≠fico
if status["throttling"]["under_voltage"]:
    print("Alerta: Detectado bajo voltaje - Verificar fuente de alimentaci√≥n")
```

> **TARS-BSK recomienda:** _Si ves `under_voltage: True`, no maldigas al c√≥digo. Maldice ese cargador de 5‚Ç¨ que compraste en una tienda de esquina cuyo logotipo era literalmente un volt√≠metro llorando. La diferencia entre 4.8V y 5.1V es la misma que entre "funcionar" y "arder en silencio mientras tu placa te grita `I/O error` desde el m√°s all√°. Invierte en una fuente decente... o aprende a soldar condensadores como si fueras un m√©dico forense reviviendo cad√°veres de silicio._


## üö® Integraci√≥n con TARS-BSK

El Guardi√°n T√©rmico no es simplemente un controlador de ventilador - es parte integral del ecosistema TARS-BSK, con comunicaci√≥n bidireccional:

1. **Influencia Emocional**: La temperatura afecta directamente el estado emocional de TARS.

```python
# Durante alta temperatura (versi√≥n actualizada):
tars.personality.set_emotion("sarcasmo", min(100, tars.personality.get_emotion("sarcasmo") + 25))

# Durante recuperaci√≥n t√©rmica:
tars.personality.set_emotion("empatia", min(100, tars.personality.get_emotion("empatia") + 20))
```

2. **Comunicaci√≥n Visual**: Integraci√≥n con el sistema de LEDs para indicaciones visuales:

```python
# Indicaci√≥n de alerta t√©rmica
if hasattr(tars.leds, "set_red"):
	tars.leds.set_red(True)  # Parpadeo rojo para alertas
```

3. **Memoria Persistente**: Eventos t√©rmicos significativos son registrados en la memoria de TARS:

```python
tars.memory.store_interaction(
	"sistema",
	alert_msg,
	"sistema",
	{"tipo": "alerta_termica", "nivel": 1, "temperatura": temp}
)
    ```

## üîß Consideraciones T√©cnicas y Optimizaciones

1. **Uso de LGPIO vs RPi.GPIO**:
- Implementaci√≥n basada en LGPIO, la biblioteca nativa recomendada para Raspberry Pi 5
- Mejora significativa en precisi√≥n PWM (>10x) respecto a implementaciones alternativas
- Soporte para frecuencias PWM personalizadas (actualmente 1000Hz)

2. **Sistema de Deque para Historial**:

```python
self.temp_history = deque(maxlen=history_size)
```

- Implementaci√≥n memory-safe con tama√±o fijo
- Eficiencia O(1) en adiciones/eliminaciones
- Evita crecimiento indefinido de memoria durante operaci√≥n extendida

3. **Intervalos Adaptativos de Monitoreo**:

```python
def _calculate_adaptive_interval(self, temp: float) -> int:
	if temp >= self.threshold:
		return max(30, int(self.base_poll_interval * 0.5))
	elif temp >= self.threshold - 10:
		return self.base_poll_interval
	else:
		return min(120, int(self.base_poll_interval * 1.5))
```

- Ahorro de recursos durante temperaturas normales
- Monitoreo intensificado durante eventos t√©rmicos cr√≠ticos
- Balance entre capacidad de respuesta y eficiencia energ√©tica


## ‚öñÔ∏è Consideraciones Finales  

ThermalGuardian proporciona un control t√©rmico robusto para Raspberry Pi 5, equilibrando rendimiento, eficiencia y seguridad. Su dise√±o modular permite adaptarse tanto a entornos integrados (TARS-BSK) como a usos independientes.  

Su dise√±o prioriza:  
- **Precisi√≥n**: Monitorizaci√≥n redundante y an√°lisis de tendencias.  
- **Seguridad**: Protocolos de emergencia escalonados.  
- **Eficiencia**: PWM optimizado para equilibrar refrigeraci√≥n y ruido.

> _¬´La termodin√°mica no negocia, pero al menos ahora tenemos las herramientas para dialogar con ella.¬ª_