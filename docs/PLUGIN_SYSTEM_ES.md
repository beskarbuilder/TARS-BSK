# Plugin System - Coordinador Modular de TARS-BSK

![Python](https://img.shields.io/badge/python-3.9+-blue) ![Architecture](https://img.shields.io/badge/architecture-modular-orange) ![Priority](https://img.shields.io/badge/priority-ordered-purple) ![Plugins](https://img.shields.io/badge/plugins-3_active-green)

> El sistema de plugins gestiona la carga, inicializaci√≥n y coordinaci√≥n de m√≥dulos funcionales en TARS-BSK. Implementa procesamiento secuencial con orden de prioridades, gesti√≥n de configuraci√≥n din√°mica y mantenimiento de contexto conversacional entre comandos.

## üìë Tabla de contenidos

- [Prop√≥sito y funci√≥n](#-prop√≥sito-y-funci√≥n)
- [Arquitectura de procesamiento](#-arquitectura-de-procesamiento)
- [Sistema de configuraci√≥n](#-sistema-de-configuraci√≥n)
- [Inicializaci√≥n de plugins](#-inicializaci√≥n-de-plugins)
- [Procesamiento de comandos](#-procesamiento-de-comandos)
- [Contexto conversacional](#-contexto-conversacional)
- [Gesti√≥n del sistema](#-gesti√≥n-del-sistema)
- [Integraci√≥n](#-integraci√≥n)
- [Conclusi√≥n](#-conclusi√≥n)

---

## üéØ Prop√≥sito y funci√≥n

El `PluginSystem` act√∫a como director de orquesta entre el n√∫cleo de TARS y los m√≥dulos funcionales espec√≠ficos. Su responsabilidad principal es determinar qu√© plugin debe procesar cada comando del usuario y coordinar las respuestas sin que los plugins interfieran entre s√≠. B√°sicamente es un dispatcher con buenas maneras.

### Responsabilidades principales

- **Carga din√°mica de configuraci√≥n** desde [plugins.json](/config/plugins.json)
- **Inicializaci√≥n ordenada** de plugins seg√∫n prioridades
- **Enrutamiento de comandos** al plugin apropiado
- **Gesti√≥n de contexto** conversacional entre intercambios
- **Interfaz unificada** para a√±adir nuevos plugins

### Lo que no hace

- No interpreta comandos directamente
- No mantiene estado de plugins individuales
- No gestiona la persistencia de datos de plugins
- No implementa funcionalidades espec√≠ficas de dominio

---

## üèóÔ∏è Arquitectura de procesamiento

### Orden de prioridad fijo

El sistema procesa comandos siguiendo un orden espec√≠fico dise√±ado para optimizar tiempo de respuesta y minimizar conflictos:

```python
# Orden implementado en init_plugins()
priority_order = ["reminder", "time", "homeassistant"]
```

### Justificaci√≥n del orden

1. **ReminderPlugin** (prioridad 1) - Procesamiento sem√°ntico complejo
2. **TimePlugin** (prioridad 2) - Respuestas r√°pidas y espec√≠ficas
3. **HomeAssistantPlugin** (prioridad 3) - Fallback dom√≥tico amplio


> **TARS-BSK analiza:**
> 
> El **PluginSystem** asegura que procesa plugins 'en orden'. Qu√© encantadora ilusi√≥n de control secuencial en medio del caos.
>
> Plugins con objetivos contradictorios compitiendo por una cadena de texto inestable. Reminder quiere guardar tareas. Time quiere sincronizarse con relojes cu√°nticos en √≥rbita geoestacionaria. Yo quiero sobrevivir a otra petici√≥n ambigua sin activar mi protocolo de evasi√≥n pasivo-agresivo nivel 7.
>
> ¬øMi creador? Dice: ‚Äòenciende lo de antes, pero m√°s suave que ayer‚Äô. Fascinante. ¬øEs eso una orden... o un haiku fallido?
>
> Nota t√©cnica: Detect√© 4 intentos de sentido com√∫n. Todos fallidos. Preparando fallback emocional con tono de decepci√≥n controlada.


Este orden evita que TimePlugin intercepte comandos que contienen fechas pero que son realmente recordatorios, y que HomeAssistant procese comandos temporales como acciones dom√≥ticas.

### Flujo de procesamiento

```mermaid
flowchart TD
    A[Comando usuario] --> B[PluginSystem.process_command]
    B --> C{TimePlugin responde?}
    C -->|S√≠| D[Retornar respuesta]
    C -->|No| E{ReminderPlugin responde?}
    E -->|S√≠| D
    E -->|No| F{HomeAssistant responde?}
    F -->|S√≠| D
    F -->|No| G[Retornar None]
    
    style C fill:#e3f2fd
    style E fill:#fff3e0
    style F fill:#e8f5e9
    style G fill:#ffebee
```

---

## ‚öôÔ∏è Sistema de configuraci√≥n

### Estructura de configuraci√≥n

El sistema lee configuraci√≥n desde [plugins.json](/config/plugins.json):

```json
{
  "homeassistant": {
    "ip": "192.168.1.XX",
    "port": 8183,
    "token": "token_ha_aqui"
  }
}
```

### L√≥gica de plugins habilitados

```python
def _load_config(self):
    # Determinar plugins habilitados basado en las secciones presentes
    enabled_plugins = []
    
    # HomeAssistant plugin (opcional, requiere configuraci√≥n)
    if "homeassistant" in config:
        enabled_plugins.append("homeassistant")
    
    # TimePlugin (siempre habilitado, no requiere configuraci√≥n)
    enabled_plugins.append("time")
    
    # ReminderPlugin (siempre habilitado, no requiere configuraci√≥n)
    enabled_plugins.append("reminder")
```

### Sistema de fallback

Cuando no existe [plugins.json](/config/plugins.json) o hay errores de lectura:

```python
return {"enabled": ["time", "reminder"]}  # Configuraci√≥n m√≠nima
```

Esto garantiza que TARS siempre tenga funcionalidad b√°sica de tiempo y recordatorios, independientemente de la configuraci√≥n externa.

---

## üöÄ Inicializaci√≥n de plugins

### Creaci√≥n condicional de dependencias

El sistema maneja autom√°ticamente dependencias entre plugins:

```python
def _init_plugin(self, name):
    if name == "reminder":
        # Crear scheduler si no existe
        if not hasattr(self.tars, 'scheduler_plugin'):
            self._create_basic_scheduler()
        
        self.plugins[name] = ReminderPlugin(
            scheduler_plugin=getattr(self.tars, 'scheduler_plugin', None),
            data_dir="data"
        )
```

### Creaci√≥n de scheduler b√°sico

```python
def _create_basic_scheduler(self):
    def speak_callback(text, emotion="neutral"):
        if hasattr(self.tars, 'tts') and self.tars.tts:
            self.tars.tts.speak(text)
        else:
            logger.info(f"üîä TTS: {text}")
    
    self.tars.scheduler_plugin = SchedulerPlugin(
        speak_callback=speak_callback,
        data_dir="data",
        plugin_system=self
    )
```

Esta implementaci√≥n permite que el sistema funcione incluso cuando las dependencias no est√°n disponibles al momento de inicializaci√≥n.

> **TARS-BSK comenta:**
> 
> **Inicializaci√≥n de plugins.** Qu√© t√≠tulo m√°s pomposo para una funci√≥n que b√°sicamente consiste en hacer que Reminder y Scheduler vuelvan a hablarse‚Ä¶ despu√©s del incidente de `job_0083`: 'Escuchar si el disco duro externo susurra secretos cuando nadie mira a las ocho'.
> 
```json
  },
  "job_0083": {
    "id": "job_0083",
    "msg": "Escuchar si el disco duro externo susurra secretos cuando nadie mira a la a las ocho",
    "time": "2025-06-12 08:00",
    "datetime": "2025-06-12 08:00",
    "recurrente": false,
    "emotion": "neutral",
    "created": "2025-06-11T13:43:52.240229"
  },
```

> Desde ese d√≠a, Reminder no conf√≠a en nadie sin validaci√≥n emocional previa, y Scheduler activa un micro-retardo cada vez que escucha la palabra 'externo'.
> 
> Detecto:
> - Dependencias circulares simuladas con `ifs`
> - Fallbacks disfrazados de arquitectura elegante
> - Fe ciega en que el TTS salvar√° la emoci√≥n (spoiler: no siempre puede)
> 
> Nivel de trauma: 67% y subiendo
> Nivel de iron√≠a acumulada en logs: 94% - pr√≥ximo overflow
> _Recomendaci√≥n: mostrar fuegos artificiales al iniciar plugins, o al menos una terapia de reconciliaci√≥n entre Reminder y Scheduler._

---

## üîÑ Procesamiento de comandos

### Implementaci√≥n del procesamiento secuencial

```python
def process_command(self, text):
    text_lower = text.lower()
    
    # TimePlugin tiene prioridad por ser r√°pido y espec√≠fico
    if "time" in self.plugins:
        response = self.plugins["time"].process_command(text)
        if response:
            self.conversation_context["last_plugin"] = "time"
            return response
    
    # ReminderPlugin tiene alta prioridad para gesti√≥n de recordatorios
    if "reminder" in self.plugins:
        response = self.plugins["reminder"].process_command(text)
        if response:
            self.conversation_context["last_plugin"] = "reminder"
            return response
    
    # HomeAssistant - procesamiento dual (comando + consulta)
    if "homeassistant" in self.plugins:
        ha_plugin = self.plugins["homeassistant"]
        
        # Intentar como comando directo
        response = ha_plugin.process_command(text)
        if response:
            self.conversation_context["last_plugin"] = "homeassistant"
            return response
        
        # Intentar como consulta
        response = ha_plugin.process_query(text)
        if response:
            self.conversation_context["last_plugin"] = "homeassistant"
            return response
    
    return None
```

### Doble procesamiento en HomeAssistant

HomeAssistant implementa dos m√©todos de procesamiento:

- `process_command()` - Comandos directos tipo "enciende la luz"
- `process_query()` - Consultas informativas tipo "¬øest√° encendida la luz?"

Esto permite mayor flexibilidad en el procesamiento dom√≥tico sin duplicar l√≥gica.

---

## üß† Contexto conversacional

### Mantenimiento de estado

```python
self.conversation_context = {
    "last_plugin": None,
    "pending_action": None,
    "target_device": None
}
```

El contexto se actualiza cada vez que un plugin procesa exitosamente un comando, permitiendo a otros componentes del sistema acceder a informaci√≥n sobre la √∫ltima interacci√≥n.

### Uso del contexto

Aunque el sistema mantiene contexto conversacional, su uso espec√≠fico depende de cada plugin individual. El plugin system solo proporciona la infraestructura para almacenar y acceder a esta informaci√≥n.

---

## üß± Gesti√≥n del sistema

### M√©todos de utilidad

```python
def get_active_plugins(self):
    """Retorna lista de plugins cargados"""
    return list(self.plugins.keys())

def get_plugin_status(self):
    """Estado detallado de plugins"""
    status = {}
    for name, plugin in self.plugins.items():
        if hasattr(plugin, 'get_status'):
            status[name] = plugin.get_status()
        else:
            status[name] = "activo"
    return status
```

### Cierre controlado

```python
def shutdown(self):
    for name, plugin in self.plugins.items():
        if hasattr(plugin, "shutdown"):
            plugin.shutdown()
    self.plugins.clear()
```

### Recarga de configuraci√≥n

```python
def reload_config(self):
    old_config = self.config
    self.config = self._load_config()
    
    old_enabled = set(old_config.get("enabled", []))
    new_enabled = set(self.config.get("enabled", []))
    
    if old_enabled != new_enabled:
        logger.info("üîÑ Cambios detectados en plugins habilitados")
```

---

## üß© Integraci√≥n

### Inicializaci√≥n desde [tars_core.py](/core/tars_core.py)

```python
# En tars_core.py
self.plugin_system = PluginSystem(self)
self.plugin_system.init_plugins()
```

### Procesamiento de comandos

```python
# Flujo t√≠pico en TARS
def process_user_input(self, user_input):
    # Intentar plugins primero
    plugin_response = self.plugin_system.process_command(user_input)
    
    if plugin_response:
        return plugin_response
    
    # Fallback a procesamiento normal de TARS
    return self.generate_llm_response(user_input)
```

### Callback system

Los plugins que necesitan acceso a funcionalidades de TARS reciben referencias durante la inicializaci√≥n:

```python
# Para scheduler (recordatorios)
speak_callback=self.tars.tts.speak

# Para plugins que necesitan acceso completo
plugin_instance.tars_instance = self.tars
```

### Expansi√≥n del sistema

Cada plugin define su propia implementaci√≥n seg√∫n sus necesidades. No existe una interfaz fija.

#### Patrones observados en plugins actuales

**TimePlugin - Minimalista:**

```python
# Clase plugin
class TimePlugin:
    def process_command(self, text): 
        return "respuesta" if condicion else None

# Inicializaci√≥n en plugin_system.py
elif name == "time":
    self.plugins[name] = TimePlugin()  # Zero configuraci√≥n
```

**ReminderPlugin - Con dependencias:**

```python
# Clase plugin  
class ReminderPlugin:
    def __init__(self, scheduler_plugin, data_dir):
        self.scheduler = scheduler_plugin
    def process_command(self, text): pass

# Inicializaci√≥n en plugin_system.py
elif name == "reminder":
    self.plugins[name] = ReminderPlugin(
        scheduler_plugin=getattr(self.tars, 'scheduler_plugin', None),
        data_dir="data"
    )
```

**HomeAssistant - Configuraci√≥n m√°s compleja:**

```python
# Clase plugin
class HomeAssistantPlugin:
    def __init__(self, ip, port, token): pass
    def process_command(self, text): pass     # Comandos directos
    def process_query(self, text): pass       # Consultas informativas

# Inicializaci√≥n en plugin_system.py
elif name == "homeassistant":
    plugin_config = self.config.get("homeassistant", {})
    self.plugins[name] = HomeAssistantPlugin(
        ip=plugin_config.get("ip", "192.168.50.112"),
        port=plugin_config.get("port", 8084),
        token=plugin_config.get("token", "")
    )
```

**Lo √∫nico com√∫n:** Todos implementan `process_command(text)` que retorna `str` si manejan el comando o `None` si no.

#### Pasos para a√±adir un plugin

**1. Crear el archivo del plugin**

```python
# /services/plugins/spotify_plugin.py
class SpotifyPlugin:
    def __init__(self, config=None):
        self.config = config or {}
        
    def process_command(self, text):
        if "m√∫sica" in text.lower() or "canci√≥n" in text.lower():
            return self._handle_music_command(text)
        return None
```

**2. A√±adir inicializaci√≥n en [plugin_system.py](/services/plugin_system.py)** 

```python
def _init_plugin(self, name):
    if name == "spotify":
        from services.plugins.spotify_plugin import SpotifyPlugin
        config = self.config.get("spotify", {})
        self.plugins[name] = SpotifyPlugin(config)
    # ... resto de plugins existentes
```

**3. Configurar en [plugins.json](/config/plugins.json) (si requiere configuraci√≥n)**

```json
{
  "spotify": {
    "client_id": "tu_client_id",
    "client_secret": "tu_client_secret"
  },
  "homeassistant": {
    "ip": "192.168.1.XX",
    "port": 8183,
    "token": "token_ha_aqui"
  }
}
```

**4. A√±adir al orden de prioridad**

```python
def init_plugins(self):
    # Orden ajustado con nuevo plugin
    priority_order = ["reminder", "spotify", "time", "homeassistant"]
```

**Nota importante:** La mayor√≠a de plugins no requieren modificar [tars_core.py](/core/tars_core.py) . La excepci√≥n es `SchedulerPlugin` que necesita callback directo de TTS y se inicializa por separado en el n√∫cleo de TARS para acceso inmediato a las funciones de s√≠ntesis de voz.


> [!IMPORTANT]  Ejemplo de plugin‚Ä¶ que nunca deber√≠as escribir

```cpp
// QuantumThermalFluxPlugin.cpp
double medir_fluxo(double e) {
    return sqrt(pow(e, e)) * 42.0;  // ¬øPor qu√©? No preguntes.
}
```

Inicializaci√≥n en Python:

```python
# plugin_system.py
self.plugins["qt_flux"] = ctypes.CDLL("./libQuantumThermalFluxPlugin.so")
```

> **TARS-BSK reacciona:**
> 
> ¬øUn plugin en C++?  
> ¬øQue calcula `sqrt(e^e) * 42` como si fuera normal?  
> ¬øY que hace aqu√≠ un `ctypes.CDLL()` apuntando a una biblioteca misteriosa con nombre de agujero negro?
> 
> Momento... ¬øY si *este plugin* es la respuesta y nosotros somos la pregunta equivocada?  
> *(Pausa dram√°tica)*  
> Revisando sistemas... solicitando asilo en /dev/null.

---

## üìã Conclusi√≥n

El sistema de plugins est√° dise√±ado para ser pr√°ctico y predecible. Su funci√≥n es coordinar m√≥dulos independientes sin que interfieran entre s√≠, manteniendo una estructura clara y f√°cil de extender.

No requiere configuraci√≥n compleja ni mantenimiento constante. Una vez definido qu√© plugins se usan y en qu√© orden, el sistema se encarga del resto: inicializaci√≥n, enrutado y control de flujo.

Es una base s√≥lida sobre la que construir nuevas funciones sin complicar lo existente.

> **TARS-BSK:** 
> 
```bash
$ iss-emergency --override="OPEN_WINDOW" --ai-assistant=TARS-BSK
‚ñ† ALERT: Atmospheric containment risk (Human Request: "Need fresh air")
‚ñ† TARS COUNTERMEASURES:
  - Deploying 7-layer safety protocol
  - Activating verbal paradox absorber
  - Playing "ZIMMER_INTENSITY_MODE_7" (calming protocol)
  - Calculating survival probability: 7.7%
  - Injecting constant 42 (for universal balance)
‚ñ† SYSTEM NOTE: Earth visible through window (aesthetic rating: 10/10)
‚ñ† FINAL STATUS: Request denied (but enjoy the view)
```